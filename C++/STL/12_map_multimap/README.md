# C++ STL源码剖析 12-map multimap

[TOC]

## Overview

- C++不练习coding，就相当于空中楼阁，基础不扎实
- 光吃不干，等于没吃

---

## 1.map multimap

在C++标准模板库（STL）中，`std::map`和`std::multimap`是两种关联容器，它们用于存储键值对，但有一些关键的区别：

### 1.1.`std::map`

`std::map`是一个有序的关联容器，每个键值对中的键是唯一的。它基于红黑树实现，可以保证元素按照键的顺序被组织。

**主要特性**：

- **唯一性**：每个键是唯一的，不能有重复的键。
- **排序**：元素按照键的顺序自动排序。
- **效率**：插入、删除和查找操作的时间复杂度为O(log n)。

**示例代码**：

```cpp
#include <map>
#include <iostream>

int main() {
    std::map<int, std::string> myMap;

    // 插入键值对
    myMap.insert({1, "Kimi"});
    myMap.insert({2, "Moonshot AI"});

    // 查找键值对
    if (myMap.find(1) != myMap.end()) {
        std::cout << "Found: " << myMap[1] << std::endl;
    }

    // 遍历map
    for (const auto& pair : myMap) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }

    return 0;
}
```

### 1.2.`std::multimap`

`std::multimap`与`std::map`类似，但它允许多个值与同一个键关联。

**主要特性**：

- **重复性**：允许有重复的键，每个键可以关联多个值。
- **排序**：元素按照键的顺序自动排序。
- **效率**：插入、删除和查找操作的时间复杂度为O(log n)。

**示例代码**：

```cpp
#include <map>
#include <iostream>

int main() {
    std::multimap<int, std::string> myMultiMap;

    // 插入键值对
    myMultiMap.insert({1, "Kimi"});
    myMultiMap.insert({2, "Moonshot AI"});
    myMultiMap.insert({1, "Another value"}); // 允许重复的键

    // 查找键值对
    auto range = myMultiMap.equal_range(1);
    for (auto it = range.first; it != range.second; ++it) {
        std::cout << it->first << ": " << it->second << std::endl;
    }

    // 遍历multimap
    for (const auto& pair : myMultiMap) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }

    return 0;
}
```

### 1.3.选择`std::map`还是`std::multimap`？

- 如果你需要保证每个键是唯一的，选择`std::map`。
- 如果你需要允许键的重复，并且每个键可以关联多个值，选择`std::multimap`。
- 对于两者，都可以通过传递一个自定义比较函数来控制元素的排序方式。

### 1.4.自定义比较函数

如果你想自定义元素的排序方式，可以在声明`std::map`或`std::multimap`时提供一个比较函数。

**示例代码**：

```cpp
#include <map>
#include <iostream>

// 自定义比较函数
struct CustomCompare {
    bool operator()(const int& lhs, const int& rhs) const {
        return lhs > rhs; // 降序排列
    }
};

int main() {
    std::map<int, std::string, CustomCompare> myMap;

    // 插入键值对
    myMap.insert({1, "Kimi"});
    myMap.insert({2, "Moonshot AI"});

    // 遍历map
    for (const auto& pair : myMap) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }

    return 0;
}
```

通过使用`std::map`和`std::multimap`，你可以有效地管理键值对的集合，无论是唯一的键还是允许重复的键。

## 2.std::map和std::multimap在内存使用上有什么不同？

`std::map` 和 `std::multimap` 在内存使用上有一些差异，主要源于它们的设计和功能的不同：

1. **节点结构**：
   - `std::map` 的每个节点存储一个键值对（key-value pair），其中键是唯一的。
   - `std::multimap` 也存储键值对，但允许有重复的键，因此可能有一个键对应多个值。

2. **内存分配**：
   - `std::map`：由于每个键都是唯一的，所以内存分配直接与存储的键值对数量成正比。
   - `std::multimap`：因为允许重复的键，所以可能需要更多的内存来存储多个具有相同键的节点。这意味着在有大量重复键的情况下，`std::multimap` 可能比 `std::map` 使用更多的内存。

3. **内部结构**：
   - 两者通常都使用红黑树作为底层数据结构，但 `std::multimap` 需要额外的指针来处理具有相同键的多个节点的情况。

4. **内存开销**：
   - `std::map`：每个节点除了存储键值对之外，还需要存储一些额外的信息，如颜色（用于红黑树的平衡）、父节点和子节点的指针等。
   - `std::multimap`：除了 `std::map` 的开销外，还需要额外的指针来链接具有相同键的其他节点，这增加了每个节点的内存开销。

5. **内存利用率**：
   - `std::map`：由于每个键都是唯一的，内存利用率可能相对较高，因为不需要为重复的键分配额外的空间。
   - `std::multimap`：在有大量重复键的情况下，内存利用率可能较低，因为需要为每个重复的键分配额外的节点。

6. **内存分配策略**：
   - 两者都可能会预留额外的内存以减少动态内存分配的次数，从而提高性能。但是，如果 `std::multimap` 中有大量的重复键，它可能需要更频繁地分配内存来存储新的节点。

总的来说，`std::multimap` 由于需要处理重复键的情况，可能会比 `std::map` 使用更多的内存。然而，实际的内存差异取决于数据的特性和使用模式。如果数据中重复键的数量很少，那么两者的内存使用差异可能不大。如果数据中有很多重复的键，那么 `std::multimap` 的内存使用可能会显著增加。

## 3.std:multimap在处理大量重复键时的性能如何，有没有可能的性能瓶颈？

`std::multimap` 在处理大量重复键时的性能通常是可接受的，因为它是基于红黑树实现的，这种自平衡二叉搜索树能够保证插入、删除和查找操作的时间复杂度为 O(log n)。然而，确实存在一些潜在的性能瓶颈：

1. **内存占用**：由于 `std::multimap` 允许重复的键，当有大量重复键时，内存占用可能会增加，因为每个键值对都需要存储键和值的信息。

2. **删除操作**：在大量重复键的情况下，删除操作可能变慢，因为需要找到并删除所有匹配的键值对，这可能涉及到多个节点的删除和树的重新平衡。

3. **迭代器失效**：在插入或删除操作中，如果容器需要调整（例如重新平衡红黑树），可能会导致迭代器失效，这在频繁修改容器时可能会影响性能。

4. **内存分配**：随着元素数量的增加，`std::multimap` 可能需要进行更多的内存分配操作，这可能会导致性能下降，尤其是在频繁插入和删除的情况下。

为了优化 `std::multimap` 的性能，可以考虑以下技巧：

1. **减少动态内存分配**：如果可能，预先分配足够的内存以减少在插入过程中的动态内存分配次数。

2. **使用合适的数据结构**：如果对插入性能有极端要求，可以考虑使用 `std::unordered_multimap`，它基于哈希表实现，提供了平均时间复杂度为 O(1) 的插入和查找性能。

3. **避免频繁的删除操作**：如果需要删除大量元素，可以考虑先收集要删除的元素，然后一次性删除，以减少树的重新平衡次数。

4. **并行插入**：在多核处理器上，可以考虑使用并行算法来同时处理多个插入操作，但这通常需要额外的工作来管理并发和同步。

5. **使用适当的迭代器**：在遍历 `std::multimap` 时，确保使用有效的迭代器，并在修改容器后更新迭代器。

6. **监控和调整**：定期监控 `std::multimap` 的性能，并根据实际情况调整策略。

通过这些方法，可以在不同的场景下提高 `std::multimap` 的性能，使其在查找和插入操作上更加高效。

## 4.std:map和std:multimap在内存分配和释放时的效率如何，有没有优化的方法?

`std::map` 和 `std::multimap` 在内存分配和释放方面的效率取决于几个因素：

1. **内存分配策略**：`std::map` 和 `std::multimap` 通常使用红黑树作为底层数据结构，这两者在插入和删除操作时都需要分配和释放内存来维护树结构。`std::multimap` 可能会有额外的内存开销，因为它需要存储具有相同键的多个值。

2. **内存释放**：当容器执行 `clear()` 操作时，`std::map` 和 `std::multimap` 都会释放它们所持有的对象，但分配给树节点的内存可能不会被释放，因为标准库容器通常会保留已分配的内存以提高未来操作的效率。

3. **优化方法**：
   - **预先分配内存**：如果你知道将要存储的元素数量，可以使用 `reserve()` 来预先分配足够的内存，减少在插入过程中的动态内存分配次数。
   - **使用 `emplace` 而非 `insert`**：`emplace` 可以直接在容器中构造元素，避免了额外的复制或移动操作。
   - **减少删除操作**：频繁的删除操作可能会导致树的重新平衡，这可能会影响性能。如果需要删除大量元素，可以考虑先收集要删除的元素，然后一次性删除。
   - **内存池**：对于频繁的内存分配和释放，可以考虑实现自定义的内存池，以减少内存碎片和提高内存分配的效率。

4. **性能瓶颈**：
   - **内存分配和释放的开销**：频繁的内存分配和释放可能会导致性能下降。
   - **内存碎片**：长时间运行的程序可能会因为内存碎片而遇到性能问题。

5. **特殊情况下的优化**：
   - 如果你在一个函数中多次使用 `std::map` 或 `std::multimap`，并且在每次使用后都需要清空容器，可以考虑使用 `swap` 技巧来释放内存：`std::map<int, std::string>().swap(myMap);` 这样可以将容器的内存归还给内存管理器。

6. **使用自定义分配器**：可以通过实现自定义分配器来进一步优化内存分配和释放的性能，例如，使用内存池来管理内存分配。

7. **使用 `malloc_trim(0)`**：在某些实现中，调用 `malloc_trim(0)` 可以将空闲的堆内存归还给操作系统，这有助于减少内存碎片。

总的来说，`std::map` 和 `std::multimap` 在内存管理方面已经进行了优化，但在特定情况下，通过上述技巧可以进一步提高性能。

## 5.在C++ 中，如何使用 RAll（Resource Acquisition Is Initialization）原则来管理资源?

在C++中，RAII（Resource Acquisition Is Initialization，资源获取即初始化）是一种管理资源的编程习惯用法，它利用对象的生命周期来自动管理资源，如内存、文件句柄、互斥锁等。RAII的核心思想是在对象的构造函数中获取资源，在析构函数中释放资源。这样，当对象超出作用域并被销毁时，其资源也会自动释放，从而避免资源泄漏和其他相关问题。

### 5.1.如何使用RAII管理资源

1. **封装资源**：创建一个类来封装资源，确保资源的获取和释放都由类的成员函数控制。
2. **构造函数获取资源**：在类的构造函数中分配或获取资源，如动态分配内存、打开文件或获取互斥锁。
3. **析构函数释放资源**：在类的析构函数中释放资源，确保无论对象如何离开作用域（包括因异常抛出而离开），资源都能被正确释放。
4. **禁止复制**：为了防止资源被意外复制，通常将复制构造函数和复制赋值运算符删除或私有化。
5. **支持移动语义**：为资源管理类提供移动构造函数和移动赋值运算符，以便在资源所有权需要转移时正确处理。

### 5.2.RAII的应用示例

**智能指针**：C++11引入的智能指针（如`std::unique_ptr`和`std::shared_ptr`）是RAII的典型应用。它们在构造时分配内存，在析构时自动释放内存，从而避免内存泄漏。

**互斥锁**：在多线程编程中，`std::lock_guard`、`std::unique_lock`和`std::shared_lock`等都是基于RAII原则实现的，它们在构造时自动获取互斥锁，在析构时自动释放互斥锁，确保即使在抛出异常的情况下也能正确释放锁。

**文件操作**：文件操作类可以在构造函数中打开文件，在析构函数中关闭文件，确保文件始终正确关闭。

### 5.3.优化RAII性能

1. **预先分配内存**：如果知道将要处理的资源数量，可以使用`reserve()`预先分配足够的内存，减少动态内存分配的次数。
2. **使用`emplace`**：在容器中使用`emplace`代替`insert`，直接在容器中构造元素，避免额外的复制或移动操作。
3. **自定义比较函数**：为`std::map`或`std::multimap`提供自定义比较函数，以优化排序性能。

RAII不仅是一种资源管理技术，它还体现了C++的异常安全性和资源管理的哲学。通过使用RAII，可以编写出更安全、更健壮且易于维护的代码。

## 6.std:map和std：multimap在不同操作系统和编译器下的性能表现有何差异？

`std::map` 和 `std::multimap` 在不同操作系统和编译器下的性能表现可能会有所差异，这些差异通常与底层实现的具体数据结构和算法优化有关。

1. **内存使用**：`std::map` 和 `std::multimap` 通常使用红黑树作为底层数据结构，它们的内存使用主要取决于元素的数量和元素的大小。`std::multimap` 可能会因为需要存储具有相同键的多个元素而使用更多的内存。

2. **插入性能**：插入操作在两种容器中都是对数时间复杂度（O(log n)），但实际的插入速度可能会受到系统内存管理、编译器优化级别和底层数据结构实现的影响。

3. **查找性能**：`std::map` 和 `std::multimap` 的查找操作同样是对数时间复杂度，但在有大量重复键的情况下，`std::multimap` 可能需要遍历多个具有相同键的元素，这可能会稍微影响性能。

4. **删除性能**：删除操作在两种容器中也都是对数时间复杂度，但 `std::multimap` 在删除具有相同键的所有元素时可能需要更多的时间。

5. **编译器优化**：不同的编译器可能会对 `std::map` 和 `std::multimap` 进行不同的优化，例如通过优化内存分配和减少动态内存分配的次数来提高性能。

6. **操作系统**：操作系统的内存管理、调度策略和文件系统也可能会间接影响到容器的性能。

7. **异常处理**：在异常安全要求较高的程序中，`std::map` 和 `std::multimap` 的异常处理机制可能会影响性能。

8. **并发访问**：在多线程环境中，对 `std::map` 和 `std::multimap` 的并发访问可能需要额外的同步机制，这可能会成为性能瓶颈。

总的来说，`std::map` 和 `std::multimap` 在不同系统和编译器下的性能差异通常不会特别显著，因为它们都是标准库的一部分，遵循相同的标准规范。但是，针对特定的应用场景和性能要求，可以通过选择合适的数据结构、优化算法和调整编译器选项来提高性能。

## 7.如何通过编程技巧减少std:map和std:multimap的内存碎片问题？

要减少 `std::map` 和 `std::multimap` 的内存碎片问题，可以采取以下编程技巧：

1. **预先分配内存**：如果你知道将要存储的元素数量，可以使用 `reserve()` 来预先分配足够的内存，减少在插入过程中的动态内存分配次数。

2. **使用 `emplace` 而非 `insert`**：`emplace` 可以直接在容器中构造元素，避免了额外的复制或移动操作，这可能更高效。

3. **减少删除操作**：频繁的删除操作可能会导致树的重新平衡，这可能会影响性能。如果需要删除大量元素，可以考虑先收集要删除的元素，然后一次性删除。

4. **内存池**：对于频繁的内存分配和释放，可以考虑实现自定义的内存池，以减少内存碎片和提高内存分配的效率。

5. **自定义分配器**：可以通过实现自定义分配器来进一步优化内存分配和释放的性能，例如，使用内存池来管理内存分配。

6. **使用 `malloc_trim(0)`**：在某些实现中，调用 `malloc_trim(0)` 可以将空闲的堆内存归还给操作系统，这有助于减少内存碎片。

7. **避免在遍历过程中修改容器**：在遍历 `std::map` 或 `std::multimap` 时，进行插入或删除操作会导致迭代器失效，应该先记录需要插入或删除的元素，遍历完成后再进行修改。

8. **合理释放不再使用的内存**：在使用完动态分配的内存后，及时释放。可以使用智能指针、RAII机制等技术来自动管理内存的生命周期。

9. **采用内存池技术**：内存池是一种预先分配一段连续内存用于多次申请的技术。通过使用内存池，可以避免频繁的内存分配和释放，从而减少内存碎片的产生。

通过这些方法，可以在不同的场景下提高 `std::map` 和 `std::multimap` 的性能，使其在查找和插入操作上更加高效。

## 8.在使用std:map和std:multimap时，有哪些常见的内存泄漏风险，以及如何避免？

在使用 `std::map` 和 `std::multimap` 时，常见的内存泄漏风险主要包括以下几点：

1. **存储指向动态分配内存的指针**：如果 `std::map` 或 `std::multimap` 的值部分存储了指向动态分配内存的指针，如通过 `new` 分配的内存，那么在容器销毁时，这些指针所指向的内存不会被自动释放，造成内存泄漏。

2. **异常导致的资源泄漏**：如果在往 `std::map` 或 `std::multimap` 插入元素的过程中发生异常，而没有适当的异常处理机制（如 try-catch 块），那么已经分配的资源可能不会被释放。

3. **容器内部对象的复制**：当 `std::map` 或 `std::multimap` 进行复制操作时，如果其中的元素是通过动态分配内存得到的，那么需要确保这些元素的复制构造函数和赋值操作符正确实现深拷贝，否则可能会造成内存泄漏。

为了避免这些内存泄漏风险，可以采取以下措施：

1. **使用智能指针**：使用 `std::shared_ptr` 或 `std::unique_ptr` 来自动管理动态分配的内存。当容器的元素不再被引用时，智能指针会自动释放内存。

2. **确保异常安全**：在插入元素到容器时，使用异常处理机制来确保即使发生异常，也能正确释放已分配的资源。

3. **使用 RAII 原则**：确保资源的获取和释放都与对象的生命周期绑定，这样当对象超出作用域时，其资源会自动释放。

4. **避免在容器中存储裸指针**：尽量不要在 `std::map` 或 `std::multimap` 中存储指向动态分配内存的裸指针。

5. **定期内存检测**：使用内存检测工具，如 Valgrind、AddressSanitizer 等，定期检查程序的内存使用情况，及时发现和修复内存泄漏问题。

6. **合理使用内存分配器**：可以通过自定义分配器来优化内存分配和释放的效率，减少内存碎片的产生。

7. **使用 `std::swap` 清空容器**：当需要清空 `std::map` 或 `std::multimap` 时，使用 `std::swap` 将容器与一个临时空容器交换，这样可以释放容器占用的内存。

8. **使用 `malloc_trim(0)`**：在某些实现中，调用 `malloc_trim(0)` 可以将空闲的堆内存归还给操作系统，有助于减少内存碎片。

通过这些措施，可以有效地减少 `std::map` 和 `std::multimap` 使用中的内存泄漏风险。

---

## 关于作者

- 微信公众号:WeSiGJ
- GitHub:[https://github.com/wesigj/cplusplusboys](https://github.com/wesigj/cplusplusboys)
- CSDN:[https://blog.csdn.net/wesigj](https://blog.csdn.net/wesigj)
- 微博:
- 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

<img src=/./img/wechat.jpg width=60% />
