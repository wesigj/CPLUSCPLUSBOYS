# C++ STL源码剖析 9-STL设计之EBO优化 空基类优化

[TOC]

## Overview

- C++不练习coding，就相当于空中楼阁，基础不扎实
- 光吃不干，等于没吃

---

## 1.空基类优化

在 C++ 中，空基类优化（Empty Base Optimization，EBO）是一种编译器优化技术，它允许空基类的大小为零，从而减少派生类的内存占用。这是通过将空基类的子对象完全优化掉来实现的，即不为其分配任何内存空间。

### 1.1.如何定义自定义迭代器

要定义一个自定义迭代器，你需要：

1. **定义迭代器类别**：指定你的迭代器是输入迭代器、输出迭代器、前向迭代器、双向迭代器还是随机访问迭代器。

2. **实现迭代器操作**：至少实现 `operator*`（解引用）、`operator++`（递增）、`operator==` 和 `operator!=`（比较）。

3. **提供迭代器特质**：使用 `std::iterator_traits` 来定义迭代器的特质，如 `value_type`、`difference_type`、`pointer` 和 `reference`。

### 1.2.自定义迭代器的示例

```cpp
template <typename T>
class MyContainer {
public:
    class iterator {
        T* ptr;
    public:
        iterator(T* p) : ptr(p) {}
        iterator& operator++() { ++ptr; return *this; }
        T& operator*() const { return *ptr; }
        bool operator==(const iterator& other) const { return ptr == other.ptr; }
        bool operator!=(const iterator& other) const { return ptr != other.ptr; }

        // 迭代器类别
        using iterator_category = std::random_access_iterator_tag;
        using value_type = T;
        using difference_type = std::ptrdiff_t;
        using pointer = T*;
        using reference = T&;
    };

    iterator begin() const { return iterator(data); }
    iterator end() const { return iterator(data + size); }

private:
    T* data;
    size_t size;
};
```

### 1.3.使用 EBO 优化 STL 容器

EBO 在 STL 容器中得到了广泛应用，如 `std::vector`、`std::deque`、`std::list` 等。通过继承空的分配器类，STL 容器可以在分配器无状态时避免为其分配额外的存储空间。

例如，`std::allocator` 是一个典型的空基类，它通常作为 STL 容器的基类，但并不增加容器的大小：

```cpp
template<typename T>
class allocator {
public:
    template<typename U>
    struct rebind { typedef allocator<U> other; };
    // ...
};
```

当你定义一个容器的实现类时，你可以继承自 `allocator`，并通过 `rebind` 来获取正确的分配器类型：

```cpp
template<typename T, typename Alloc>
class vector_impl : public Alloc {
    // ...
};
```

如果 `Alloc` 是一个空基类，那么 `vector_impl` 的大小不会因为继承而增加。

### 1.4.注意事项

- **EBO 仅适用于空基类**：如果基类不是空的，或者有非静态成员变量，EBO 不会生效。
- **EBO 与对象模型**：EBO 要求基类子对象在对象模型中可以完全优化掉，这通常意味着基类不能有状态。
- **编译器支持**：不同的编译器对 EBO 的支持可能有所不同，但主流编译器如 GCC 和 Clang 都支持 EBO。

通过使用 EBO，可以有效地减少 STL 容器的内存占用，提高内存使用效率。

## 2.EBO 在 C++ 中是如何被编译器识别和应用的？

在 C++ 中，空基类优化（Empty Base Optimization，EBO）是一种编译器优化技术，它允许空基类的大小为零，从而减少派生类的内存占用。这是通过将空基类的子对象完全优化掉来实现的，即不为其分配任何内存空间。

### 2.1.EBO 的工作机制

当一个类继承自一个或多个空基类时，如果满足特定条件，编译器可以优化派生类的布局，使得空基类不占用任何额外的内存空间。这样，派生类的对象就可以在内存中与第一个非空成员紧挨着排列。

### 2.2.EBO 的条件

EBO 在以下情况下通常被应用：

1. **空基类**：基类不包含任何非静态数据成员。
2. **非最终类**：派生类不是最终类（没有 `final` 关键字）。
3. **非多重继承**：没有多个空基类直接或间接继承自同一个基类。
4. **非首个成员**：空基类不是派生类中首个非静态数据成员的类型。

### 2.3.EBO 的应用

EBO 在 STL 中得到了广泛应用，例如：

- **`std::vector`**：使用 EBO 来优化其分配器成员的存储。
- **`std::function`**：使用 EBO 来优化存储小的函数对象。
- **`std::shared_ptr`**：使用 EBO 来优化其内部的控制块。

### 2.4.示例代码

以下是一个简单的示例，展示了如何使用 EBO：

```cpp
class EmptyBase {
};

class Derived : public EmptyBase {
    int data;
public:
    Derived() : data(42) {}
};

int main() {
    static_assert(sizeof(Derived) == sizeof(int), "EBO should apply.");
    return 0;
}
```

在这个示例中，`Derived` 类继承自一个空基类 `EmptyBase`，并且 `sizeof(Derived)` 应该等于 `sizeof(int)`，因为 EBO 被应用了。

### 2.5.注意事项

- **编译器支持**：不是所有的编译器都支持 EBO，或者在所有情况下都应用 EBO。
- **多重继承**：如果存在多个空基类，EBO 的行为可能会更复杂。
- **C++20**：从 C++20 开始，即使空类的大小可以是 0，EBO 也是必需的，以确保对象的地址唯一性。

EBO 是一种有效的内存优化技术，可以在不牺牲代码清晰度和易用性的前提下，减少内存使用。

## 3.EBO 在 C++ 中的优化是如何影响程序性能的？

空基类优化（Empty Base Optimization，EBO）是一种编译器优化技术，它允许空基类的大小为零，从而减少派生类的内存占用。这是通过将空基类的子对象完全优化掉来实现的，即不为其分配任何内存空间。

EBO 在 STL 容器中得到了广泛应用，如 `std::vector`、`std::deque`、`std::list` 等。通过继承空的分配器类，STL 容器可以在分配器无状态时避免为其分配额外的存储空间。例如，`std::allocator` 是一个典型的空基类，它通常作为 STL 容器的基类，但并不增加容器的大小。

EBO 的应用可以显著减少内存消耗并提高程序的性能。在 STL 中，容器是一类非常重要的数据结构，用于存储和管理元素集合。常见的容器包括 vector、list、map 等。为了提高容器的性能和内存效率，STL 使用了 EBO 来设计容器类。

EBO 的优化效果在 STL 中尤为显著，因为 STL 中的容器类通常需要维护大量的元素，对内存的使用效率要求较高。通过合理地设计类的继承关系，将空基类的尺寸优化为零，从而减少内存消耗并提高程序的性能。

EBO 通常在以下情况下被应用：

1. **空基类**：基类不包含任何非静态数据成员。
2. **非最终类**：派生类不是最终类（没有 `final` 关键字）。
3. **非多重继承**：没有多个空基类直接或间接继承自同一个基类。
4. **非首个成员**：空基类不是派生类中首个非静态数据成员的类型。

在 C++20 中，EBO 是标准布局类型所必需的，以确保可以通过 `reinterpret_cast` 将标准布局类型的指针转换为其初始成员的地址。此外，C++20 引入了 `[[no_unique_address]]` 属性，允许成员子对象被优化掉，就像空基类一样，如果它们使用这个属性。

总的来说，EBO 是一种有效的内存优化技术，可以在不牺牲代码清晰度和易用性的前提下，减少内存使用，从而提高程序的性能。

## 4.EBO 在 C++ 中的实现原理是什么？

EBO（Empty Base Optimization，空基类优化）是C++中的一个优化技术，它允许空基类的大小在某些情况下为零，从而减少派生类的大小。这种优化在C++11及以后的版本中得到了广泛应用。

在C++中，一个空类（没有数据成员的类）通常也会占用至少一个字节的内存，这是为了确保每个对象都有一个唯一的地址。但是，当空类作为基类时，编译器可以将其优化掉，使得派生类不因为继承了空基类而增加额外的内存开销。

EBO的实现原理如下：

1. **空基类的定义**：如果一个类不包含任何非静态数据成员（包括没有成员变量、没有继承、没有数据元素的类），则该类被认为是空类。

2. **空基类的优化条件**：当空类作为基类时，如果满足以下条件，编译器可以不为其分配内存：
   - 空基类不是派生类中第一个非静态数据成员的类型或其基类。
   - 空基类没有被用作多个基类，否则会导致地址重复的问题。

3. **EBO的应用**：EBO通常用于标准库中，如`std::vector`、`std::function`、`std::shared_ptr`等，这些类通过包含一个空的分配器类来避免占用额外的存储空间。

4. **EBO的限制**：如果空基类是第一个非静态数据成员的类型，或者空基类本身是另一个空基类的子类，则EBO不适用。

5. **EBO的实现**：在实现EBO时，可以通过私有继承空基类来实现，这样既可以使用空基类的成员函数，又不会增加派生类的内存开销。

6. **EBO的效果**：使用EBO可以显著减少对象的大小，如在某些情况下，一个包含空基类的派生类对象可能只包含其自有成员变量的大小。

例如，考虑以下代码：

```cpp
class Empty {}; // 空类
class Derived : public Empty {
    int i;
};
```

在应用EBO的情况下，`sizeof(Derived)` 的结果将与 `sizeof(int)` 相同，因为空基类 `Empty` 没有占用额外的空间。

EBO是现代C++编译器中常见的优化手段，它有助于提高内存使用效率，尤其是在实现标准库容器时非常有用。

## 5.如何确保自定义迭代器的EBO特性在所有编译器中都能正常工作？

要确保自定义迭代器的EBO特性在所有编译器中都能正常工作，你需要遵循一些最佳实践：

1. **避免虚继承**：虚继承可能会阻止EBO，因为它需要一个vptr来访问虚基类。

2. **使用私有继承**：如果你的迭代器类继承自一个空的迭代器类，使用私有继承可以避免增加额外的存储开销。

3. **确保基类是空的**：基类应该没有非静态数据成员，这样才能确保EBO生效。

4. **避免多重继承**：多重继承可能会使EBO变得复杂，尤其是在涉及多个空基类的情况下。

5. **使用C++11或更高版本的标准**：EBO在C++11及以后的版本中得到了更好的支持。

6. **使用`[[maybe_unused]]`或`[[no_unique_address]]`（C++20）**：如果你的编译器支持C++20，可以使用`[[no_unique_address]]`属性来指示编译器该基类不需要唯一的地址。

7. **测试在不同编译器**：不同的编译器可能对EBO的支持有所不同，因此在不同的编译器上进行测试是很重要的。

8. **避免基类中有构造函数或析构函数**：即使基类是空的，如果它有构造函数或析构函数，也可能会影响EBO。

9. **使用标准库容器作为参考**：标准库容器如`std::vector`、`std::string`等都使用了EBO，可以作为实现自定义迭代器时的参考。

10. **关注编译器的优化报告**：一些编译器提供了优化报告功能，可以帮助你了解EBO是否生效以及为什么。

通过遵循这些实践，你可以提高自定义迭代器在不同编译器中EBO特性正常工作的可能性。记住，EBO是由编译器决定的，所以最终结果可能会因编译器的不同而有所差异。

## 6.除了STL容器，EBO还可以用在哪些场景中？

EBO（Empty Base Optimization，空基类优化）是一种编译器优化技术，它允许从空基类派生的派生类对象不包含空基类的部分，从而节省内存空间。这种优化在C++标准库的STL容器中得到了广泛应用，如`std::vector`、`std::deque`、`std::list`等，它们内部都使用了空基类优化来减少内存占用。

除了STL容器，EBO还可以应用于以下场景：

1. **自定义容器**：在设计自定义容器时，可以利用EBO来减少内存开销。例如，可以设计一个内存分配器基类，然后在容器类中私有继承这个分配器，以实现内存管理的优化。

2. **智能指针**：在实现自定义智能指针时，可以使用EBO来避免额外的内存占用。例如，`std::shared_ptr`和`std::unique_ptr`内部就使用了EBO技术。

3. **函数对象封装**：在模板编程中，函数对象经常需要最小的对象表示。通过使用EBO，可以确保函数对象的实例占用的内存最小化。

4. **协议类**：在设计接口或抽象类时，可以定义一个没有任何数据成员的类，然后在实现类中继承这个协议类，以确保接口的实现不会增加额外的内存开销。

5. **状态机实现**：在状态机的设计中，可以定义一个空的状态基类，然后在具体的状态类中继承这个基类，这样可以减少状态对象的大小。

6. **混合(Mixin)类**：Mixin类是一种用于代码复用的类，它们通常不包含数据成员，只包含虚函数。使用EBO可以确保Mixin类不会增加派生类的大小。

7. **资源管理**：在资源管理类中，如文件句柄管理、网络连接管理等，可以使用EBO来避免额外的内存开销。

8. **游戏开发**：在游戏开发中，对象和实体的数量往往非常庞大，使用EBO可以减少对象内存占用，提高性能。

9. **嵌入式系统**：在内存资源受限的嵌入式系统中，EBO可以用来优化内存使用，提高程序的内存效率。

10. **库和框架开发**：在开发通用库或框架时，使用EBO可以确保库的使用者不会因为额外的内存开销而受到影响。

实现EBO时，需要注意以下几点：

- 确保基类是空的，即不包含任何数据成员。
- 避免在空基类中定义构造函数、析构函数或虚函数，这些都会阻止EBO。
- 使用私有继承来避免引入额外的虚函数表指针。

通过合理地设计类的继承关系，可以有效地利用EBO来优化程序的内存使用。

---

## 关于作者

- 微信公众号:WeSiGJ
- GitHub:[https://github.com/wesigj/cplusplusboys](https://github.com/wesigj/cplusplusboys)
- CSDN:[https://blog.csdn.net/wesigj](https://blog.csdn.net/wesigj)
- 微博:
- 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

<img src=/./img/wechat.jpg width=60% />
