# C++11 21-统一的内存模型 Unified memory model

- [C++11 21-统一的内存模型 Unified memory model](#c11-21-统一的内存模型-unified-memory-model)
  - [Overview](#overview)
  - [1.统一的内存模型 Unified memory model](#1统一的内存模型-unified-memory-model)
  - [2.C++11中的原子操作是如何保证线程安全的关键技术是什么？](#2c11中的原子操作是如何保证线程安全的关键技术是什么)
  - [3.C++11 中的原子操作在实际编程中有哪些常见的应用场景？](#3c11-中的原子操作在实际编程中有哪些常见的应用场景)
  - [4.如何使用C++11的原子操作来避免虚假共享问题？](#4如何使用c11的原子操作来避免虚假共享问题)
  - [5.在C++11中，如何使用~std::atomic\`库来实现线程安全的内存操作？](#5在c11中如何使用stdatomic库来实现线程安全的内存操作)
    - [5.1. 包含头文件](#51-包含头文件)
    - [5.2. 使用 `std::atomic`](#52-使用-stdatomic)
    - [5.3. 基本操作](#53-基本操作)
    - [5.4.示例代码](#54示例代码)
    - [5.5. 内存顺序](#55-内存顺序)
    - [5.6. 避免虚假共享](#56-避免虚假共享)
    - [5.7. 实现复杂的同步机制](#57-实现复杂的同步机制)
    - [5.8. 使用 `std::atomic_flag`](#58-使用-stdatomic_flag)
  - [6.内存顺序解析](#6内存顺序解析)
    - [6.1.为什么需要内存顺序](#61为什么需要内存顺序)
    - [6.2.C++11 中的内存顺序选项](#62c11-中的内存顺序选项)
    - [6.3.示例](#63示例)
    - [6.4.总结](#64总结)
  - [7.C++11的内存模型对于无锁编程有哪些具体的影响和优势？](#7c11的内存模型对于无锁编程有哪些具体的影响和优势)
  - [关于作者](#关于作者)

## Overview

---

## 1.统一的内存模型 Unified memory model

C++11引入了统一的内存模型，这是对C++并发编程的一个重要改进。在C++11之前，C++标准并没有定义一个明确的内存模型，这导致多线程程序的行为在不同的平台和编译器上可能会有所不同。C++11的内存模型提供了以下关键特性：

1. **原子操作**：C++11引入了`std::atomic`库，支持对基本数据类型的原子操作，确保在多线程环境中对这些类型的操作是安全的。

2. **内存顺序**：C++11定义了内存顺序模型，它规定了操作的执行顺序和内存的可见性。内存顺序模型包括`memory_order_relaxed`、`memory_order_acquire`、`memory_order_release`、`memory_order_acq_rel`和`memory_order_seq_cst`等不同的内存顺序选项，允许开发者控制原子操作的顺序和同步。

3. **happens-before关系**：这是C++11内存模型中的核心概念之一，它定义了操作之间的顺序关系。如果一个操作A happens-before 操作B，那么操作A对操作B可见，且操作A的执行顺序在操作B之前。

4. **synchronizes-with关系**：这是happens-before关系的一个特例，用于描述原子操作之间的同步关系。如果一个原子操作A synchronizes-with 另一个原子操作B，那么在操作B之后，操作A的所有修改都对操作B可见。

5. **线程局部存储**：C++11通过`thread_local`关键字支持线程局部存储，每个线程都有其私有的变量副本，这有助于避免线程间的数据竞争。

6. **条件变量**：C++11标准库提供了条件变量，允许线程在某些条件尚未满足时挂起，并在条件满足时被唤醒，这有助于实现线程间的协调和同步。

7. **互斥锁**：虽然C++11之前就已经有互斥锁的使用，但C++11的内存模型为互斥锁提供了更好的支持，确保了锁操作的原子性和内存顺序的正确性。

8. **无锁编程**：C++11的内存模型和原子操作为无锁编程提供了基础，使得开发者可以在不使用互斥锁的情况下实现线程安全的程序。

C++11的内存模型和并发编程特性为开发者提供了一套完整的工具，用于编写可预测、可移植且高效的多线程程序。通过合理使用这些特性，可以在多核处理器上实现高性能的并发程序。

## 2.C++11中的原子操作是如何保证线程安全的关键技术是什么？

C++11 引入的原子操作通过以下几个关键技术来保证线程安全：

1. **原子类型（`std::atomic`）**：
   `std::atomic` 是 C++11 引入的一个模板类，它提供了对内置数据类型的原子操作。这些类型包括整数类型、指针类型、浮点类型等。

2. **内存顺序（Memory Ordering）**：
   原子操作可以指定内存顺序，它定义了操作的执行顺序和对其他线程的可见性。C++11 定义了以下内存顺序模型：
   - `std::memory_order_relaxed`：不对执行顺序做任何保证。
   - `std::memory_order_consume`：确保在当前原子操作之前的依赖操作对后续操作可见。
   - `std::memory_order_acquire`：确保在当前原子操作之前的所有操作在获取锁之后对其他线程可见。
   - `std::memory_order_release`：确保在当前原子操作之前的所有操作在释放锁之前对其他线程可见。
   - `std::memory_order_acq_rel`：结合了 `acquire` 和 `release` 的语义。
   - `std::memory_order_seq_cst`：提供严格的顺序一致性保证。

3. **锁自由编程（Lock-Free Programming）**：
   原子类型和操作通常用于实现锁自由的数据结构，这些数据结构不需要互斥锁来保证线程安全，从而减少了线程同步的开销。

4. **避免虚假共享（False Sharing）**：
   原子操作通过确保访问的数据在内存中的位置与其他线程可能访问的数据不重叠，来避免虚假共享，从而提高缓存效率。

5. **编译器和硬件支持**：
   原子操作依赖于底层编译器和硬件对原子性的支持。编译器和处理器通过使用特定的原子指令集（如 x86 的 CMPXCHG 指令）来保证操作的原子性。

6. **细粒度操作**：
   `std::atomic` 提供了对单个数据点的原子操作，而不是整个数据结构，这允许更细粒度的并发控制。

7. **异常安全**：
   原子操作通常保证在抛出异常时不会留下不完整或不一致的状态。

8. **延迟执行（Deferred Execution）**：
   原子操作可以与条件变量结合使用，允许线程在条件满足之前挂起，并在条件满足时被唤醒。

通过这些技术，C++11 的原子操作为多线程程序提供了一种有效的方式来实现线程安全，同时避免了传统锁机制可能带来的问题，如死锁或上下文切换的开销。

## 3.C++11 中的原子操作在实际编程中有哪些常见的应用场景？

在 C++11 中，原子操作因其线程安全性和无锁特性，在多线程编程中有广泛的应用。以下是一些常见的应用场景：

1. **计数器**：
   用于多线程环境中的计数器，确保计数的原子性，如访问频次统计。

   ```cpp
   std::atomic<int> counter(0);
   ```

2. **线程安全的数据结构**：
   实现无锁或线程安全的数据结构，如无锁队列、栈、链表等。

   ```cpp
   std::atomic<std::shared_ptr<Node>> head;
   ```

3. **状态标志**：
   用于表示某个状态，如线程的运行状态、任务的完成状态等。

   ```cpp
   std::atomic<bool> done(false);
   ```

4. **并发算法**：
   实现某些并发算法，如并发累加器、投票算法等。

   ```cpp
   std::atomic<int> sum(0);
   ```

5. **引用计数**：
   用于对象的引用计数，尤其是在共享指针的实现中。

   ```cpp
   std::atomic<int> ref_count(0);
   ```

6. **同步原语**：
   实现同步原语，如信号量、条件变量、屏障等。

   ```cpp
   std::atomic<bool> ready(false);
   ```

7. **缓存行标记**：
   用于控制缓存行的使用，避免伪共享。

   ```cpp
   std::atomic<char> pad[128];
   ```

8. **资源绑定**：
   将资源（如内存、文件句柄等）与线程绑定，确保资源的线程局部性。

   ```cpp
   std::atomic<void*> resource;
   ```

9. **负载均衡**：
   在工作窃取模型中，用于实现工作队列，平衡负载。

   ```cpp
   std::atomic<int> task_count(0);
   ```

10. **日志系统**：
    实现高性能的并发日志系统，确保日志的顺序和原子性。

11. **网络编程**：
    用于原子性地更新和读取网络缓冲区的读写位置。

12. **性能计数器**：
    用于在多线程程序中计算执行时间、指令周期等性能指标。

使用原子操作时，应该考虑操作的内存顺序要求，以确保数据的一致性和操作的原子性。同时，合理的使用原子操作可以避免锁的开销，提高程序的性能。

## 4.如何使用C++11的原子操作来避免虚假共享问题？

在 C++11 中，原子操作是避免虚假共享问题的关键技术之一。虚假共享发生在多个线程频繁更新同一缓存行上的不同变量时，这会导致性能下降，因为缓存行在不同处理器核心之间的无效交换。

以下是一些使用原子操作来避免虚假共享的策略：

1. **使用原子变量**：
   使用 `std::atomic` 类型的变量可以确保操作的原子性，从而减少锁的使用，提高并发性能。原子变量通常比非原子变量更小，因此它们不太可能与其他变量共享缓存行。

   ```cpp
   std::atomic<int> count(0);
   ```

2. **缓存行对齐**：
   通过确保每个线程访问的变量在不同的缓存行上，可以减少虚假共享。可以使用特殊的对齐指令，如 `alignas`，来确保变量在内存中的正确对齐。

   ```cpp
   alignas(64) std::atomic<int> count(0); // 假设缓存行大小为64字节
   ```

3. **填充（Padding）**：
   在变量之间添加填充字节，以确保它们位于不同的缓存行上。这种方法可以减少不同线程对同一缓存行的变量的访问冲突。

   ```cpp
   struct alignas(64) CacheAlignedInt {
       std::atomic<int> value;
   };
   ```

4. **无锁数据结构**：
   使用原子操作实现无锁数据结构，如无锁队列、栈等，可以避免锁的开销，并减少虚假共享的可能性。

5. **避免共享**：
   尽可能设计并发算法，使得每个线程工作在独立的数据块上，避免多个线程频繁访问同一数据。

6. **使用内存屏障**：
   在原子操作中使用适当的内存顺序（memory ordering），如 `std::memory_order_acquire` 和 `std::memory_order_release`，可以插入内存屏障，防止指令重排，从而避免虚假共享。

7. **减少原子操作的数量**：
   减少对原子操作的依赖，通过设计更高效的并发算法，可以减少对共享资源的争用。

8. **使用线程局部存储**：
   使用 `thread_local` 关键字声明的变量为每个线程提供了独立的副本，从而避免了共享数据的争用。

通过这些策略，可以在多线程程序中有效地使用原子操作来避免虚假共享，从而提高程序的性能。

## 5.在C++11中，如何使用~std::atomic`库来实现线程安全的内存操作？

在 C++11 中，`std::atomic` 库是实现线程安全的内存操作的关键工具。以下是使用 `std::atomic` 来实现线程安全的步骤和示例：

### 5.1. 包含头文件

首先，包含必要的头文件：

```cpp
#include <atomic>
#include <thread>
```

### 5.2. 使用 `std::atomic`

使用 `std::atomic` 类模板来定义需要线程安全的变量。`std::atomic` 支持多种数据类型，如 `int`、`float`、`pointer` 等。

### 5.3. 基本操作

`std::atomic` 提供了一系列原子操作，如加载（load）、存储（store）、交换（exchange）、增加（fetch_add）和减少（fetch_sub）等。

### 5.4.示例代码

以下是一个使用 `std::atomic` 实现线程安全的计数器的示例：

```cpp
#include <atomic>
#include <iostream>
#include <thread>

std::atomic<int> count(0); // 原子计数器初始化为0

void increment() {
    for (int i = 0; i < 10000; ++i) {
        count.fetch_add(1, std::memory_order_relaxed); // 原子增加操作
    }
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);

    t1.join();
    t2.join();

    std::cout << "Final count: " << count.load() << std::endl; // 输出最终计数结果
    return 0;
}
```

### 5.5. 内存顺序

`std::atomic` 操作可以指定内存顺序，以控制操作的执行顺序和可见性。C++11 定义了以下内存顺序：

- `std::memory_order_relaxed`：不提供任何同步或排序保证。
- `std::memory_order_consume`：确保在该操作之后的操作能够看到该操作之前的所有依赖操作。
- `std::memory_order_acquire`：确保在该操作之后的所有操作在获取锁之后对其他线程可见。
- `std::memory_order_release`：确保在该操作之前的所有操作在释放锁之前对其他线程可见。
- `std::memory_order_acq_rel`：结合了 `acquire` 和 `release` 的语义。
- `std::memory_order_seq_cst`：提供顺序一致性的保证。

### 5.6. 避免虚假共享

为了避免虚假共享，可以在原子变量之间添加填充（padding），确保它们位于不同的缓存行上。

```cpp
struct alignas(64) AtomicCounter {
    std::atomic<int> value;
};

AtomicCounter counter;
```

### 5.7. 实现复杂的同步机制

`std::atomic` 可以用于实现更复杂的同步机制，如无锁队列、条件变量等。

### 5.8. 使用 `std::atomic_flag`

`std::atomic_flag` 是一种特殊的原子类型，用于实现锁自由的同步机制，如自旋锁。

```cpp
std::atomic_flag flag = ATOMIC_FLAG_INIT;
flag.test_and_set(std::memory_order_acquire); // 尝试设置标志并获取锁
// ... 执行临界区代码 ...
flag.clear(std::memory_order_release); // 释放锁
```

通过以上步骤和示例，你可以使用 `std::atomic` 库在 C++11 中实现线程安全的内存操作。这些原子操作有助于避免数据竞争和提高多线程程序的性能。

## 6.内存顺序解析

内存顺序（Memory Ordering）是多线程编程中一个非常重要的概念，它定义了在多线程环境中执行操作的顺序，以及这些操作对其他线程的可见性。在 C++11 和后续标准中，通过原子操作提供的内存顺序选项，可以精细控制操作的执行顺序和内存的可见性。

### 6.1.为什么需要内存顺序

在多核处理器和多线程环境中，为了提高性能，编译器和处理器可能会对指令进行重排。这种重排可能导致意想不到的并发问题，比如数据竞争和不一致的内存访问。内存顺序通过限制编译器和处理器的优化行为，确保了操作的有序性和内存的可见性。

### 6.2.C++11 中的内存顺序选项

C++11 标准定义了以下内存顺序选项：

1. **`std::memory_order_relaxed`**：
   - 不提供任何同步或排序保证。适用于不需要同步的操作，比如简单的标志位。
   - 使用场景：当你只需要一个无锁的数据结构，并且不关心操作顺序时。

2. **`std::memory_order_consume`**：
   - 确保在当前原子操作之前的所有操作对在这个操作之后执行的依赖操作可见。
   - 使用场景：用于构建依赖于特定操作顺序的复杂数据结构。

3. **`std::memory_order_acquire`**：
   - 确保在当前原子操作之前的所有操作在获取锁之后对其他线程可见。
   - 使用场景：用于同步操作，比如在锁的获取之后。

4. **`std::memory_order_release`**：
   - 确保在当前原子操作之前的所有操作在释放锁之前对其他线程可见。
   - 使用场景：用于同步操作，比如在锁的释放之前。

5. **`std::memory_order_acq_rel`**：
   - 结合了 `acquire` 和 `release` 的语义，适用于读写锁等需要双向同步的场景。
   - 使用场景：适用于读写锁的实现。

6. **`std::memory_order_seq_cst`**：
   - 提供顺序一致性的保证，这是最强的内存顺序保证。
   - 使用场景：当你需要确保所有线程看到一致的操作顺序时。

### 6.3.示例

考虑一个简单的计数器，使用 `std::memory_order_relaxed` 和 `std::memory_order_seq_cst`：

```cpp
#include <atomic>
#include <thread>
#include <vector>

std::atomic<int> count(0);

void increment(int n) {
    for (int i = 0; i < n; ++i) {
        count.fetch_add(1, std::memory_order_relaxed);
    }
}

int main() {
    std::vector<std::thread> threads;
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back(increment, 1000);
    }
    for (auto& t : threads) {
        t.join();
    }
    std::cout << "Final count: " << count.load(std::memory_order_seq_cst) << std::endl;
    return 0;
}
```

在这个例子中，如果使用 `std::memory_order_relaxed`，编译器和处理器可能会重排指令，导致计数器的最终值可能小于10000。如果使用 `std::memory_order_seq_cst`，则确保了所有线程看到一致的顺序，最终值将准确为10000。

### 6.4.总结

内存顺序是确保多线程程序正确性和性能的关键。通过合理选择内存顺序，可以在保持程序性能的同时，避免并发问题。

## 7.C++11的内存模型对于无锁编程有哪些具体的影响和优势？

C++11的内存模型对无锁编程的影响和优势主要体现在以下几个方面：

1. **原子操作**：C++11通过`std::atomic`提供了一套原子类型，确保了对这些类型的操作是原子的，即在多线程环境中不会被中断。这是无锁编程的基础，因为它允许开发者在没有传统锁的情况下安全地操作共享数据。

2. **内存顺序控制**：C++11内存模型定义了不同的内存顺序选项（如`std::memory_order_relaxed`、`std::memory_order_acquire`、`std::memory_order_release`等），允许开发者精确控制原子操作的执行顺序和内存的可见性。这有助于避免虚假共享和不必要的同步，从而提高无锁编程的性能。

3. **happens-before关系**：C++11内存模型中的happens-before关系为无锁编程提供了一种机制，确保在多线程环境中操作的有序性和一致性。这种关系定义了一组规则，用于确定一个操作在程序的执行中何时对其他操作可见。

4. **避免锁的开销**：无锁编程通过使用原子操作来避免使用互斥锁，这减少了线程阻塞和上下文切换的开销，提高了程序的并发性能。

5. **减少死锁和饥饿问题**：由于无锁编程不依赖于锁机制，它减少了死锁和线程饥饿的风险，提高了程序的稳定性和可靠性。

6. **提高实时响应性**：无锁编程的低延迟特性使其非常适合实时系统，如智能驾驶的域控制系统，其中对响应时间有严格要求。

7. **无锁数据结构**：C++11的内存模型支持实现各种无锁数据结构，如无锁队列、栈、哈希表等，这些数据结构在多线程环境中提供了高并发性，同时避免了线程阻塞和死锁问题。

8. **内存屏障**：C++11提供了`std::atomic_thread_fence`函数，用于实现内存屏障，确保内存操作的顺序，这对于无锁编程中的同步和数据一致性至关重要。

总的来说，C++11的内存模型为无锁编程提供了一套完整的工具和规则，使得开发者能够在不牺牲性能和正确性的前提下，编写出更高效、更可靠的多线程程序。

---

## 关于作者

- 微信公众号:WeSiGJ
- GitHub:[https://github.com/wesigj/cplusplusboys](https://github.com/wesigj/cplusplusboys)
- CSDN:[https://blog.csdn.net/wesigj](https://blog.csdn.net/wesigj)
- 微博:
- 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

<img src=/./img/wechat.jpg width=60% />
