# C++11 11-委托构造函数 Delegating constructors

- [C++11 11-委托构造函数 Delegating constructors](#c11-11-委托构造函数-delegating-constructors)
  - [Overview](#overview)
  - [1.委托构造函数 Delegating constructors](#1委托构造函数-delegating-constructors)
    - [1.1.如何使用委托构造函数](#11如何使用委托构造函数)
    - [1.2.为什么使用委托构造函数](#12为什么使用委托构造函数)
    - [1.3.注意事项](#13注意事项)
  - [2.在 C++11 中，委托构造函数和普通构造函数有什么区别？](#2在-c11-中委托构造函数和普通构造函数有什么区别)
    - [2.1.委托构造函数](#21委托构造函数)
    - [2.2.普通构造函数](#22普通构造函数)
    - [2.3.示例](#23示例)
    - [2.4.区别总结](#24区别总结)
  - [3.如何避免在C++11中使用委托构造函数时出现循环委托的问题？](#3如何避免在c11中使用委托构造函数时出现循环委托的问题)
    - [3.1.示例](#31示例)
  - [4.C++11中的委托构造函数在哪些情况下比手动编写初始化列表更高效？](#4c11中的委托构造函数在哪些情况下比手动编写初始化列表更高效)
    - [4.1.如何使用委托构造函数](#41如何使用委托构造函数)
    - [4.2.委托构造函数的优势](#42委托构造函数的优势)
    - [4.3.注意事项](#43注意事项)
    - [4.4.性能优化](#44性能优化)
    - [4.5.实际应用](#45实际应用)
  - [5.在C++11中，委托构造函数的调用顺序是如何确定的？](#5在c11中委托构造函数的调用顺序是如何确定的)
    - [5.1.调用顺序规则](#51调用顺序规则)
    - [5.2.示例](#52示例)
    - [5.3.注意事项](#53注意事项)
    - [5.4.总结](#54总结)
  - [6.如何使用委托构造函数来优化类的构造过程？](#6如何使用委托构造函数来优化类的构造过程)
    - [6.1. **重用初始化代码**](#61-重用初始化代码)
    - [6.2. **简化构造函数**](#62-简化构造函数)
    - [6.3. **保持构造函数的清晰性**](#63-保持构造函数的清晰性)
    - [6.4. **提高代码的可维护性**](#64-提高代码的可维护性)
    - [6.5. **使用初始化列表**](#65-使用初始化列表)
    - [6.6. **避免循环委托**](#66-避免循环委托)
    - [6.7. **考虑异常安全性**](#67-考虑异常安全性)
  - [7.除了委托构造函数，C++11还引I入了哪些有助于提高代码清晰度的特性？](#7除了委托构造函数c11还引i入了哪些有助于提高代码清晰度的特性)
  - [关于作者](#关于作者)

## Overview

---

## 1.委托构造函数 Delegating constructors

在 C++11 中，委托构造函数是一种特殊的构造函数，它允许一个构造函数调用同一个类中的另一个构造函数来初始化对象。这种机制可以避免在多个构造函数中重复相同的初始化代码，从而提高代码的清晰度和可维护性。

### 1.1.如何使用委托构造函数

委托构造函数通过在成员初始化列表中调用另一个构造函数来实现。以下是一个简单的示例：

```cpp
class MyClass {
public:
    // 基础构造函数
    MyClass(int value) : value_(value) {}

    // 委托构造函数
    MyClass() : MyClass(0) {}

    // 另一个委托构造函数
    MyClass(int value, std::string name) : MyClass(value) {
        this->name_ = std::move(name);
    }

private:
    int value_;
    std::string name_;
};
```

在这个例子中，`MyClass()` 委托给 `MyClass(int value)`，而 `MyClass(int value, std::string name)` 又委托给 `MyClass(int value)`。

### 1.2.为什么使用委托构造函数

1. **减少代码重复**：多个构造函数可以共享相同的初始化代码。
2. **提高代码清晰度**：通过将初始化逻辑分解到不同的构造函数中，代码更加模块化。
3. **增强类的可维护性**：当需要修改初始化逻辑时，只需在一个地方进行更改。
4. **支持类的灵活设计**：允许派生类重用基类的构造函数或在派生类中重用其他构造函数的初始化逻辑。

### 1.3.注意事项

- **避免循环委托**：委托构造函数不能形成一个环，否则会导致编译错误或无限递归。
- **成员初始化**：委托构造函数不能初始化成员变量，只能调用另一个构造函数。

通过使用委托构造函数，你可以编写更加简洁和易于维护的代码，特别是在处理具有多个构造函数的类时。

## 2.在 C++11 中，委托构造函数和普通构造函数有什么区别？

在 C++11 中，委托构造函数（Delegating Constructors）和普通构造函数在用途和行为上有一些关键的区别：

### 2.1.委托构造函数

1. **定义**：委托构造函数是一种特殊的构造函数，它通过在初始化列表中调用同一个类中的另一个构造函数来实现初始化。
2. **语法**：委托构造函数使用成员初始化列表来调用另一个构造函数，而不是在函数体内。
3. **目的**：用于避免在多个构造函数中重复相同的初始化代码，提高代码的清晰度和可维护性。
4. **行为**：委托构造函数直接将初始化工作委托给另一个构造函数，减少了代码冗余。

### 2.2.普通构造函数

1. **定义**：普通构造函数是类中定义的用于初始化对象的函数。
2. **语法**：普通构造函数在其函数体内包含初始化代码。
3. **目的**：用于在对象创建时初始化成员变量。
4. **行为**：普通构造函数可能会包含一些特定的初始化逻辑，这些逻辑在不同的构造函数中可能会有所不同。

### 2.3.示例

```cpp
class MyClass {
public:
    // 普通构造函数
    MyClass(int x) : value(x) {
        // 执行一些初始化工作
    }

    // 委托构造函数
    MyClass() : MyClass(0) {
        // 可以在这里添加一些仅适用于这个构造函数的初始化工作
    }

    // 另一个委托构造函数
    MyClass(int x, std::string str) : MyClass(x) {
        // 委托给另一个构造函数
        this->str = std::move(str);
    }

private:
    int value;
    std::string str;
};
```

在这个例子中，`MyClass()` 委托给 `MyClass(int x)`，而 `MyClass(int x, std::string str)` 又委托给 `MyClass(int x)`。

### 2.4.区别总结

- **委托构造函数**：在初始化列表中调用另一个构造函数，不能包含任何执行语句。
- **普通构造函数**：在函数体内包含初始化代码，可以包含执行语句。

委托构造函数是 C++11 引入的特性，它允许程序员编写更简洁、更易于维护的代码，尤其是在处理具有多个构造函数的类时。通过使用委托构造函数，可以避免在多个构造函数中重复相同的初始化代码。

## 3.如何避免在C++11中使用委托构造函数时出现循环委托的问题？

在 C++ 中使用委托构造函数时，确保不会出现循环委托的问题是非常重要的。循环委托发生在一个构造函数直接或间接地试图调用自身，导致无限递归。以下是一些避免循环委托的策略：

1. **明确构造函数职责**：
   为每个构造函数定义明确的职责，并确保它们不会相互依赖。每个构造函数应该只调用一个未委托的构造函数。

2. **使用初始化列表**：
   委托构造函数应该使用初始化列表来调用另一个构造函数，而不是在构造函数体内进行调用。

3. **避免多重委托**：
   确保构造函数不会进行多重委托，即一个委托到另一个，而另一个又委托回第一个。

4. **使用直接初始化**：
   如果可能，使用直接初始化来替代委托构造函数，特别是在构造函数逻辑简单时。

5. **检查构造函数链**：
   在编写构造函数之前，检查类的所有构造函数，并确保它们形成的链是线性的，没有闭环。

6. **使用继承**：
   如果类继承自基类，并且基类的构造函数已经执行了所需的初始化，派生类可以委托给基类的构造函数。

7. **使用聚合初始化**：
   对于聚合类，成员变量的初始化是隐式的，因此不需要委托构造函数。

8. **使用常量成员**：
   如果类包含常量成员，它们必须在所有构造函数的初始化列表中初始化。

9. **重构代码**：
   如果发现循环委托，考虑重构代码以消除循环依赖。

10. **编译器检查**：
    现代 C++ 编译器通常能够检测到循环委托并报错，利用编译器的错误信息来诊断问题。

### 3.1.示例

以下是一个避免循环委托的示例：

```cpp
class MyClass {
public:
    // 基础构造函数
    MyClass(int x) : value_(x) {}

    // 委托构造函数
    MyClass() : MyClass(0) {}

    // 另一个构造函数
    MyClass(int x, std::string str) : value_(x), str_(std::move(str)) {}

private:
    int value_;
    std::string str_;
};
```

在这个例子中，`MyClass()` 委托给 `MyClass(int x)`，而 `MyClass(int x, std::string str)` 委托给 `MyClass(int x)`，没有循环委托。

通过遵循上述策略，你可以避免在 C++11 中使用委托构造函数时出现循环委托的问题。

## 4.C++11中的委托构造函数在哪些情况下比手动编写初始化列表更高效？

在 C++11 中，委托构造函数是一种特殊的构造函数，它允许一个构造函数调用同一个类中的另一个构造函数来完成初始化工作。这种机制可以避免在多个构造函数中重复相同的初始化代码，从而提高代码的清晰度和可维护性 。

### 4.1.如何使用委托构造函数

委托构造函数通过在成员初始化列表中调用另一个构造函数来实现。例如：

```cpp
class MyClass {
public:
    MyClass(int value) : value_(value) {}
    MyClass() : MyClass(0) {}  // 委托构造函数
private:
    int value_;
};
```

在这个例子中，`MyClass()` 委托给 `MyClass(int value)`。

### 4.2.委托构造函数的优势

1. **减少代码重复**：多个构造函数可以共享相同的初始化代码。
2. **提高代码清晰度**：通过将初始化逻辑集中在一个构造函数中，代码更加清晰。
3. **增强类的可维护性**：当需要修改初始化逻辑时，只需在一个地方进行更改。

### 4.3.注意事项

- **避免循环委托**：委托构造函数不能形成一个环，否则会导致编译错误或无限递归。
- **成员初始化**：委托构造函数不能初始化成员变量，只能调用另一个构造函数。
- **使用`std::move`**：在需要移动语义的情况下，使用 `std::move` 来避免不必要的复制。

### 4.4.性能优化

委托构造函数通常比手动编写初始化列表更高效，因为它减少了重复代码，使得编译器可以优化生成的代码。此外，由于初始化逻辑集中，编译器可能生成更优化的初始化序列。

### 4.5.实际应用

在实际应用中，当一个类有多个构造函数且它们共享相同的初始化逻辑时，使用委托构造函数可以简化代码。例如，一个类有不同的构造函数来处理不同的参数组合，但它们都需要执行一些基本的初始化工作，这时可以使用委托构造函数来简化实现。

总之，委托构造函数是 C++11 提供的一个强大特性，它可以帮助程序员编写更简洁、更高效的代码。

## 5.在C++11中，委托构造函数的调用顺序是如何确定的？

在 C++11 中，委托构造函数的调用顺序是由你在类定义中所写的委托关系决定的。委托构造函数通过在构造函数的初始化列表中明确调用另一个构造函数来实现。这种调用关系是线性的，并且调用顺序是从基构造函数到派生构造函数。

### 5.1.调用顺序规则

1. **首先调用基类的构造函数**：如果类继承自一个基类，基类的构造函数将首先被调用。
2. **然后调用委托的构造函数**：接下来调用被委托的构造函数，这通常是类中定义的其他构造函数。
3. **成员变量初始化**：在委托构造函数之后，成员变量将按照它们在类定义中的声明顺序进行初始化。

### 5.2.示例

考虑以下类定义，其中包含了委托构造函数：

```cpp
class Base {
public:
    Base(int x) : value(x) {}
    int value;
};

class Derived : public Base {
public:
    Derived() : Base(10), other_member(20) {}
    Derived(int x) : Base(x), other_member(0) {}
    float other_member;
};
```

在这个例子中：

1. **对于 `Derived()` 构造函数**：
   - 首先调用基类 `Base` 的构造函数，传递 `10` 作为参数。
   - 然后初始化成员变量 `other_member`，赋值为 `20`。

2. **对于 `Derived(int x)` 构造函数**：
   - 首先调用基类 `Base` 的构造函数，传递 `x` 作为参数。
   - 然后初始化成员变量 `other_member`，赋值为 `0`。

### 5.3.注意事项

- **初始化顺序**：成员变量的初始化顺序是由它们在类定义中的声明顺序决定的，而不是由构造函数的顺序决定的。
- **避免循环委托**：确保没有循环委托的情况，即构造函数 A 委托给构造函数 B，构造函数 B 又委托回构造函数 A，这会导致编译错误。

### 5.4.总结

委托构造函数的调用顺序是由你在类定义中指定的初始化列表决定的。这种机制允许你重用代码，减少重复的初始化代码，并保持代码的清晰和可维护性。通过合理地组织委托关系和初始化列表，可以有效地控制对象的初始化过程。

## 6.如何使用委托构造函数来优化类的构造过程？

委托构造函数是 C++11 引入的特性，它允许一个构造函数调用同一个类中的另一个构造函数来初始化对象。这种机制可以减少代码重复，使构造函数更加清晰和易于维护。以下是如何使用委托构造函数来优化类的构造过程的一些建议：

### 6.1. **重用初始化代码**

如果有多个构造函数执行相同的初始化步骤，可以将这些步骤放在一个构造函数中，然后让其他构造函数委托给它。

```cpp
class MyClass {
public:
    // 基础构造函数
    MyClass(int value) : value_(value) {}

    // 委托构造函数
    MyClass() : MyClass(0) {}

    // 另一个构造函数
    MyClass(int value, std::string name) : MyClass(value), name_(std::move(name)) {}

private:
    int value_;
    std::string name_;
};
```

在这个例子中，`MyClass()` 委托给 `MyClass(int value)`，而 `MyClass(int value, std::string name)` 委托给 `MyClass(int value)`。

### 6.2. **简化构造函数**

通过委托构造函数，可以避免在多个构造函数中重复书写相同的初始化代码。

```cpp
class MyClass {
public:
    MyClass(int value) : value_(value) {}

    MyClass(int value, std::string name) : MyClass(value), name_(std::move(name)) {}

private:
    int value_;
    std::string name_;
};
```

### 6.3. **保持构造函数的清晰性**

委托构造函数可以帮助保持每个构造函数的清晰性和专注性，每个构造函数只关注一部分初始化工作。

### 6.4. **提高代码的可维护性**

当需要修改初始化逻辑时，如果使用了委托构造函数，你只需要在一个地方进行修改，而不是在多个构造函数中重复修改。

### 6.5. **使用初始化列表**

确保委托构造函数使用初始化列表来调用另一个构造函数，而不是在构造函数体内调用。

```cpp
class MyClass {
public:
    MyClass(int value) : value_(value) {}

    MyClass() : MyClass(0) {}  // 正确的委托方式
    // ...
private:
    int value_;
    // ...
};
```

### 6.6. **避免循环委托**

检查你的构造函数，确保没有循环委托的情况，即构造函数 A 委托给构造函数 B，构造函数 B 又委托回构造函数 A。

### 6.7. **考虑异常安全性**

委托构造函数在进行对象初始化时，应确保遵循异常安全的准则，避免在初始化过程中抛出异常。

通过使用委托构造函数，你可以编写更加清晰、简洁和易于维护的代码，特别是在处理具有多个构造函数的类时。

## 7.除了委托构造函数，C++11还引I入了哪些有助于提高代码清晰度的特性？

C++11 引入了许多有助于提高代码清晰度的特性，除了委托构造函数外，还包括：

1. **自动类型推导（Auto）**：`auto` 关键字允许编译器自动推导变量的类型，减少模板编程中的冗长类型声明 。

2. **基于范围的 for 循环**：提供了一种新的循环语法，使遍历容器和数组更加直观和简洁 。

3. **nullptr 关键字**：`nullptr` 提供了一种类型安全的空指针字面量，取代了传统的 `NULL` 。

4. **初始化列表（Initializer lists）**：允许使用花括号 `{}` 初始化对象，提高了代码的一致性和清晰度 。

5. **Lambda 表达式**：允许在需要的地方定义匿名函数，简化了函数对象的创建和使用 。

6. **右值引用和移动语义**：通过右值引用 `&&` 和移动构造函数，支持资源的移动而不是复制，提高了性能 。

7. **强类型枚举（enum class）**：提供了类型安全的枚举，避免了枚举值和整数之间的隐式转换 。

8. **模板增强**：包括变参模板、外部模板和类型别名模板，使模板编程更加灵活和强大 。

9. **多线程支持**：标准库中引入了线程相关的支持，如 `std::thread`、`std::mutex` 等，简化了并发编程 。

10. **类型别名（Type Aliases）和类型推断**：`using` 关键字用于定义类型别名，简化了复杂的类型名称 。

11. **线程局部存储（Thread-local storage）**：`thread_local` 关键字用于定义线程特定的数据 。

12. **属性规范（Attributes）**：如 `[[noreturn]]` 用于标记不会返回的函数，提供了一种新的方式来指定函数属性 。

这些特性共同作用，使得 C++11 代码更加简洁、安全和易于维护。

---

## 关于作者

- 微信公众号:WeSiGJ
- GitHub:[https://github.com/wesigj/cplusplusboys](https://github.com/wesigj/cplusplusboys)
- CSDN:[https://blog.csdn.net/wesigj](https://blog.csdn.net/wesigj)
- 微博:
- 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

<img src=/./img/wechat.jpg width=60% />
