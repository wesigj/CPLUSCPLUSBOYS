# C++11 34-Hash Function

- [C++11 34-Hash Function](#c11-34-hash-function)
  - [Overview](#overview)
  - [1.Hash Function](#1hash-function)
  - [2.C++11 中的 `std::hash` 函数是如何实现的，它使用了哪种哈希算法？](#2c11-中的-stdhash-函数是如何实现的它使用了哪种哈希算法)
  - [3.如何为自定义类型编写一个合适的哈希函数，以确保哈希表的高效性？](#3如何为自定义类型编写一个合适的哈希函数以确保哈希表的高效性)
    - [3.1. 理解哈希函数的基本要求](#31-理解哈希函数的基本要求)
    - [3.2. 使用简单函数组合](#32-使用简单函数组合)
    - [3.3. 考虑成员变量的权重](#33-考虑成员变量的权重)
    - [3.4. 避免常见的哈希冲突](#34-避免常见的哈希冲突)
    - [3.5. 使用高质量的哈希算法](#35-使用高质量的哈希算法)
    - [3.6. 测试哈希函数](#36-测试哈希函数)
    - [3.7. 考虑使用复合哈希](#37-考虑使用复合哈希)
      - [3.7.1.示例：复合哈希](#371示例复合哈希)
    - [3.8. 考虑使用第三方库](#38-考虑使用第三方库)
  - [4.除了使用`std:hash`还有哪些方法可以用于实现哈希表？](#4除了使用stdhash还有哪些方法可以用于实现哈希表)
  - [关于作者](#关于作者)

## Overview

---

## 1.Hash Function

在 C++11 中，`std::hash` 是一个函数对象模板，它为多种标准库类型提供了默认的哈希函数实现。它位于 `<functional>` 头文件中，并且是无序关联容器（如 `std::unordered_map` 和 `std::unordered_set`）的默认哈希函数。`std::hash` 为基本数据类型提供了特化，包括整数类型、浮点类型、指针类型以及 `std::string` 类型等。

如果你需要为自定义类型提供哈希函数，可以通过两种方式：

1. **自定义哈希函数对象**：
   你可以定义一个结构体或类，并为其重载 `operator()`，使其成为一个可以被 `std::unordered_map` 和 `std::unordered_set` 等容器使用的哈希函数对象。

   ```cpp
   struct MyHash {
       std::size_t operator()(int x) const {
           return std::hash<int>()(x);
       }
   };
   ```

2. **特化 `std::hash`**：
   你可以在 `std` 命名空间中特化 `std::hash` 模板，为你的类型提供哈希函数。

   ```cpp
   namespace std {
       template<>
       struct hash<MyClass> {
           std::size_t operator()(const MyClass& obj) const {
               // 计算并返回哈希值
               return std::hash<int>()(obj.someMember);
           }
       };
   }
   ```

在实现哈希函数时，应该确保满足以下条件：

- 对于相等的对象，哈希函数必须产生相同的哈希值。
- 哈希函数不应该抛出异常。
- 哈希函数应该尽可能均匀地分布哈希值，以减少哈希冲突。

C++11 标准并没有规定 `std::hash` 的具体实现，但是它必须满足上述条件。在实践中，不同的编译器可能会有不同的实现，例如在 MSVC 中，`std::hash` 可能使用 FNV 哈希算法。

在实际应用中，你可以使用 `std::hash` 来快速实现哈希表功能，或者自定义哈希函数来满足特定需求。例如，如果你有一个复杂的数据结构，你可能需要自定义哈希函数来确保高效的哈希表操作。

## 2.C++11 中的 `std::hash` 函数是如何实现的，它使用了哪种哈希算法？

在 C++11 中，`std::hash` 是一个模板结构，用于为标准库中的容器提供哈希函数。它位于 `<functional>` 头文件中，并且是无序关联容器（如 `std::unordered_map` 和 `std::unordered_set`）的默认哈希函数实现。

`std::hash` 为多种基本数据类型提供了特化，包括整数类型、浮点类型、指针类型以及 `std::string` 类型等。对于自定义类型，可以通过特化 `std::hash` 来提供自定义的哈希函数。

在实现上，不同的编译器可能会采用不同的哈希算法。例如，在 MSVC 中，`std::hash` 可能使用 FNV（Fowler-Noll-Vo）哈希算法作为实现 。FNV 哈希算法是一种快速、冲突率低的哈希算法，适用于哈希大量数据。

FNV 算法有三个版本：FNV-0（已废弃）、FNV-1 和 FNV-1a。它通过一个偏移基数（offset basis）和一个质数（FNV prime）来计算哈希值。对于不同的数据大小（32位、64位、128位等），FNV 算法有相应的质数和偏移基数。

FNV-1 算法的描述如下：

1. 初始化哈希值 `hash` 为偏移基数（offset basis）。
2. 对于每个要哈希的八位字节（octet），执行以下操作：
   - 将 `hash` 乘以 FNV 质数。
   - 将 `hash` 与八位字节进行异或操作。

在自定义类型时，可以通过特化 `std::hash` 来提供哈希函数，例如：

```cpp
struct MyType {
    int value;
    // ...
};

namespace std {
    template<>
    struct hash<MyType> {
        size_t operator()(const MyType& obj) const {
            // 计算哈希值的逻辑
            return std::hash<int>()(obj.value);
        }
    };
}
```

或者使用自定义的哈希函数对象：

```cpp
struct MyHash {
    size_t operator()(const MyType& obj) const {
        // 计算哈希值的逻辑
        return std::hash<int>()(obj.value);
    }
};
```

在实际应用中，合理实现和使用 `std::hash` 可以提高哈希表操作的性能，尤其是在涉及到大量数据和高并发访问的场景中。

## 3.如何为自定义类型编写一个合适的哈希函数，以确保哈希表的高效性？

为自定义类型编写一个合适的哈希函数，以确保哈希表的高效性，需要考虑几个关键因素：分布均匀性、快速计算、以及尽量减少哈希冲突。以下是一些步骤和技巧，帮助你为自定义类型编写哈希函数：

### 3.1. 理解哈希函数的基本要求

- **快速性**：哈希函数的计算应该尽可能快，避免复杂计算。
- **均匀分布**：哈希函数应该能够均匀地将键分布在哈希表中，避免哈希碰撞。
- **确定性**：相同的键总是应该产生相同的哈希值。
- **最小冲突**：好的哈希函数应该尽量减少哈希冲突。

### 3.2. 使用简单函数组合

对于简单的数据类型，一个好的起点是使用简单的位操作和算术操作组合。例如：

```cpp
struct MyType {
    int a, b;

    bool operator==(const MyType& other) const {
        return a == other.a && b == other.b;
    }
};

namespace std {
    template<>
    struct hash<MyType> {
        size_t operator()(const MyType& obj) const {
            size_t h1 = std::hash<int>()(obj.a);
            size_t h2 = std::hash<int>()(obj.b);
            return h1 ^ (h2 << 1);  // 示例：组合两个成员的哈希值
        }
    };
}
```

### 3.3. 考虑成员变量的权重

如果你的类型由多个成员变量组成，考虑每个成员对最终哈希值的贡献。例如，如果某个成员更重要，可以让它在哈希计算中占更大的权重。

### 3.4. 避免常见的哈希冲突

- **等概率冲突**：确保哈希函数能够处理并减少等概率冲突，即那些自然出现的、导致多个键具有相同哈希值的情况。

### 3.5. 使用高质量的哈希算法

对于复杂类型，考虑使用或参考已知的高质量哈希算法，如 MurmurHash、CityHash、SpookyHash 等。

### 3.6. 测试哈希函数

- **测试均匀性**：确保哈希函数生成的值在整个哈希范围内均匀分布。
- **测试冲突率**：检查哈希函数在实际使用中是否会产生过多的冲突。

### 3.7. 考虑使用复合哈希

如果类型由多个字段组成，考虑将每个字段的哈希值组合起来。例如，可以使用异或、加法或其他位操作来组合多个哈希值。

#### 3.7.1.示例：复合哈希

```cpp
namespace std {
    template<>
    struct hash<MyType> {
        size_t operator()(const MyType& obj) const {
            size_t h1 = std::hash<int>()(obj.a);
            size_t h2 = std::hash<int>()(obj.b);
            return h1 ^ (h2 >> 1);  // 组合哈希
        }
    };
}
```

### 3.8. 考虑使用第三方库

如果可能，考虑使用已经优化好的第三方哈希库，如 Google 的 CityHash 或 Mozilla 的 MurmurHash。

通过遵循上述步骤和技巧，你可以为你的自定义类型编写一个合适的哈希函数，以确保哈希表的高效性。

## 4.除了使用`std:hash`还有哪些方法可以用于实现哈希表？

在 C++ 中，除了使用 `std::hash`，有多种方法可以实现哈希表。以下是一些常见的方法：

1. **自定义哈希函数**：
   可以编写自己的哈希函数，为特定类型生成哈希值。这通常涉及到位操作、乘法、加法等操作，以及可能的哈希值组合。

2. **组合多个哈希函数**：
   如果有多个字段需要考虑，可以将每个字段的哈希值组合起来，形成最终的哈希值。

3. **使用第三方哈希库**：
   使用第三方哈希库，如 MurmurHash、CityHash、SpookyHash 等，这些库提供了经过优化的哈希函数实现。

4. **利用编译器特性**：
   某些编译器提供了内置的哈希函数，如 GCC 的 `__builtin_hash`。

5. **使用哈希表库**：
   使用现成的哈希表库，如 `boost::unordered_set` 或 `boost::unordered_map`，这些库提供了自己的哈希表实现。

6. **实现开放寻址哈希表**：
   开放寻址是一种哈希表实现方式，其中所有的元素都存储在哈希表数组中，发生冲突时，通过探查序列找到下一个空槽位。

7. **实现链表哈希表**：
   链表哈希表在每个数组槽位上维护一个链表，所有映射到同一个哈希值的元素都存储在该槽位的链表中。

8. **双重哈希**：
   双重哈希使用两个哈希函数来确定元素的位置，当第一个哈希函数产生冲突时，使用第二个哈希函数来找到另一个槽位。

9. **线性探测**：
   线性探测是一种解决哈希冲突的方法，当插入元素时，如果当前槽位已被占用，则线性地检查下一个槽位，直到找到空位。

10. **二次探测**：
    二次探测是另一种解决哈希冲突的方法，它在发生冲突时按照二次函数的步长来探测新的位置。

11. **使用位图**：
    对于某些类型的键，可以使用位图来实现哈希表，这在处理大量布尔值时非常有效。

12. **使用完美哈希函数**：
    如果可能，可以为一组固定的键设计完美哈希函数，完美哈希函数保证了没有哈希冲突。

13. **使用 C++11 标准库中的无序容器**：
    `std::unordered_set` 和 `std::unordered_map` 是基于哈希表实现的，可以直接使用。

14. **实现自己的哈希表**：
    可以从头开始实现自己的哈希表，包括哈希函数、冲突解决策略、动态扩容等。

选择合适的哈希表实现方法取决于具体需求、数据特征、性能要求等因素。在实际应用中，通常会选择现成的哈希表库，因为它们经过了优化，提供了良好的性能和稳定性。

---

## 关于作者

- 微信公众号:WeSiGJ
- GitHub:[https://github.com/wesigj/cplusplusboys](https://github.com/wesigj/cplusplusboys)
- CSDN:[https://blog.csdn.net/wesigj](https://blog.csdn.net/wesigj)
- 微博:
- 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

<img src=/./img/wechat.jpg width=60% />
