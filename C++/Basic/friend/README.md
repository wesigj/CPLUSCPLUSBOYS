# C++面试基础系列-friend

[TOC]

## Overview

在C++中，`friend`是一个关键字，它用于声明友元函数或友元类。友元是一种特殊的实体，它不是类的成员，但有权访问类的私有（`private`）和保护（`protected`）成员。使用`friend`可以突破类的封装性，让特定的函数或类访问类的内部细节。

## 1.friend友元的常见用法

以下是一些关于`friend`在C++中的用法：

1. **友元函数**：可以声明为友元的函数能够访问类的非公共成员。

   ```cpp
   class MyClass {
   private:
       int privateData;

   public:
       MyClass(int val) : privateData(val) {}

       friend void accessPrivateData(MyClass& obj); // 声明友元函数
   };

   void accessPrivateData(MyClass& obj) {
       // 直接访问obj的私有成员
       std::cout << obj.privateData << std::endl;
   }
   ```

2. **友元类**：可以声明为友元的类的所有成员函数都能够访问声明它的类的私有和保护成员。

   ```cpp
   class FriendClass;

   class MyClass {
   private:
       int privateData;

   public:
       MyClass(int val) : privateData(val) {}

       friend class FriendClass; // 声明友元类
   };

   class FriendClass {
   public:
       void accessPrivateData(MyClass& obj) {
           // 直接访问obj的私有成员
           std::cout << obj.privateData << std::endl;
       }
   };
   ```

3. **友元在多文件编程中的使用**：在多文件项目中，需要在类声明中和实现文件中都声明友元函数或类。

   ```cpp
   // MyClass.h
   class MyClass {
       // ...
       friend void myFriendFunction(MyClass&);
   };

   // MyClass.cpp
   void myFriendFunction(MyClass& obj) {
       // ...
   }
   ```

4. **限制**：友元不能继承。一个类不能从友元类那里继承访问权限。

5. **使用场景**：当需要让函数或类访问内部数据，但又不想暴露这些数据给其他用户时，使用友元是一个合适的选择。

6. **注意事项**：过度使用友元可能会破坏封装性，导致代码难以维护。应当谨慎使用，只在必要时使用友元。

友元是C++中实现特定设计和优化性能的一种手段，但应当在确保不破坏类的封装性的前提下使用。

## 2.友元函数和友元类在实际编程中有哪些常见的应用场景？

友元函数和友元类在C++编程中有几种常见的应用场景，主要包括：

1. **访问私有数据**：当一个函数需要访问类的私有成员，但又不想让这个函数成为类的成员函数时，可以将其声明为友元函数。

2. **实现辅助操作**：一些操作可能在逻辑上不属于任何类，但需要访问特定类的私有成员。例如，用于操作或修改多个类内部状态的辅助函数。

3. **实现特定算法**：某些算法可能需要访问多个类的私有数据，但算法本身与这些类没有继承或组合关系。通过声明友元函数，可以在不暴露类内部实现细节的前提下实现算法。

4. **操作符重载**：对于非成员函数的运算符重载，如`<<`用于输出流，可能需要访问类的私有成员。在这种情况下，运算符重载函数常常被声明为友元。

5. **实现序列化和反序列化**：在进行对象的序列化和反序列化时，可能需要访问对象的所有成员，包括私有成员。通过友元函数可以提供这种访问权限。

6. **实现单例模式**：在实现单例模式时，友元函数可以用来访问私有构造函数，确保只有一个实例被创建。

7. **实现工厂模式**：在工厂模式中，工厂类可能需要访问多个产品的私有构造函数来创建对象实例。通过声明工厂类为友元类，可以访问这些私有成员。

8. **实现访问者模式**：访问者模式中，访问者需要对元素对象执行操作，但元素对象的内部结构需要保护。通过将访问者声明为元素类的友元，可以访问其内部结构。

9. **实现数据库或文件存储**：在将对象存储到数据库或文件系统时，可能需要访问对象的私有成员以序列化数据。友元函数可以提供这种访问权限。

10. **实现性能优化**：在某些性能敏感的应用中，友元函数可以用来减少对象拷贝或直接操作对象的内部数据结构，从而提高性能。

11. **实现测试和调试工具**：在开发测试或调试工具时，可能需要访问类的内部状态，通过友元可以提供这种访问。

使用友元时需要谨慎，因为它们破坏了类的封装性。过度使用友元可能导致代码难以理解和维护，因此应当在确保必要性和合理性的前提下使用。

## 3.如何正确地在C++中使用友元类来优化多线程程序的性能？

在C++中，使用友元类（friend class）可以优化多线程程序的性能，主要体现在以下几个方面：

1. **减少数据拷贝**：通过允许友元类直接访问另一个类的私有成员，可以避免在多线程间传递和拷贝大量数据，从而提高效率 。

2. **提高访问速度**：友元类可以无需通过公共接口直接访问类的私有成员，这减少了方法调用的开销，在多线程环境中，这可以减少同步所需的时间 。

3. **简化线程间通信**：在多线程程序中，线程间通信是一个常见需求。使用友元类可以简化线程间的直接数据交换和通信，避免了复杂的同步机制 。

4. **优化资源管理**：在多线程环境中，资源的共享和访问控制尤为重要。友元类可以访问类的私有资源管理方法，帮助实现更细粒度的资源控制和优化 。

5. **避免竞态条件**：当多个线程需要访问同一资源时，使用友元类可以设计出更安全的访问模式，因为友元类可以访问用于同步的私有成员，如互斥锁，从而避免竞态条件 。

6. **提高代码的封装性和可维护性**：尽管友元类会破坏一定的封装性，但如果合理使用，可以使得多线程程序的逻辑更加清晰，提高代码的可维护性 。

7. **实现特定的设计模式**：在某些设计模式中，如享元模式或代理模式，友元类可以用来实现对象之间的直接联系，这在多线程环境中可以减少间接层的开销 。

8. **线程池管理**：在实现线程池时，可以使用友元类来允许线程池管理线程的创建和销毁，同时直接访问线程的私有状态和数据，从而提高线程池的效率和响应速度 。

9. **线程同步**：在多线程同步中，友元类可以用来实现同步机制，比如通过友元类访问线程的私有同步数据，实现条件变量、信号量等同步手段 。

10. **提高数据局部性**：通过友元类，可以将频繁访问的数据结构的成员直接暴露给特定线程或线程局部使用，提高CPU缓存的数据局部性，从而提升性能 。

总之，友元类在多线程程序中的应用可以带来性能上的优化，但同时也需要谨慎使用，以避免过度耦合和破坏封装性。

## 4.在C++中，除了使用友元，还有哪些方式可以访问类的私有成员？

在C++中，除了使用友元（friend），以下是一些可以访问类私有（private）或保护（protected）成员的方式：

1. **类成员函数**：类的成员函数可以直接访问类的私有和保护成员。

2. **类的友元函数**：通过在类内部声明为`friend`的函数可以访问类的私有和保护成员。

3. **继承**：如果一个类是从另一个类继承来的（即使用`private`继承），即使基类的成员是私有的，派生类也可以访问这些成员。

4. **转换构造函数**：如果类有一个转换构造函数或转换运算符，它可以将对象转换为另一个类型，并且如果那个类型有访问权限，就可以访问私有成员。

5. **lambda 表达式**：在C++14中，可以在类的成员函数中捕获`*this`，然后使用lambda表达式来访问私有成员。

6. **模板函数**：通过模板函数可以访问类的私有成员，因为模板实例化时会根据模板参数的具体类型来访问成员。

7. **嵌套类**：如果一个类被定义在另一个类的内部，它自然就可以访问外部类的私有成员。

8. **静态成员函数**：静态成员函数可以直接访问类的私有和保护静态成员。

9. **标准库算法**：一些标准库算法，如`std::for_each`，可以配合函数对象或lambda表达式来访问对象的私有成员。

10. **序列化和反序列化**：在进行对象的序列化和反序列化时，可以通过友元函数或模板函数来访问对象的私有成员。

11. **反射**：使用一些第三方库，如Boost.Hana，可以实现反射机制，从而访问类的私有成员。

12. **内存字节直接访问**：虽然不推荐使用，但可以通过直接操作内存字节的方式来访问对象的私有成员，这通常涉及到`reinterpret_cast`和指针运算。

13. **代理类**：创建一个可以访问私有成员的代理类，通过代理类来访问或修改私有成员。

14. **单例模式**：如果类是单例的，那么整个程序中只有一个实例，可以通过这个全局访问点来访问私有成员。

15. **全局函数**：虽然全局函数通常不能直接访问类的私有成员，但如果它们被声明为类的友元，就可以访问。

请注意，尽管有多种方式可以访问类的私有成员，但应当谨慎使用这些方法，以维护类的封装性和数据的安全性。

## 5.除了友元，还有哪些设计模式可以用于访问类的私有成员？

除了使用友元，以下是一些设计模式，它们可以在不同程度上用于访问或操作类的私有成员：

1. **代理模式（Proxy Pattern）**：
   代理模式提供了对目标对象的间接访问，控制对它的访问。代理可以在不暴露对象实现细节的情况下，允许访问其私有成员。

2. **适配器模式（Adapter Pattern）**：
   适配器模式可以转换一个类的接口，以便它可以与预期的接口兼容。在转换过程中，可以访问类的私有成员。

3. **外观模式（Facade Pattern）**：
   外观模式提供了一个统一的高层接口，用于访问子系统中的一群接口。在这种情况下，外观类可以访问子系统中类的私有成员。

4. **桥接模式（Bridge Pattern）**：
   桥接模式将抽象与实现分离，使它们可以独立变化。在桥接模式中，实现类可以访问抽象类的私有成员。

5. **装饰器模式（Decorator Pattern）**：
   装饰器模式可以在不修改对象自身的基础上，动态地给对象添加额外的职责。装饰者可以访问被装饰对象的私有成员。

6. **组合模式（Composite Pattern）**：
   组合模式允许将对象组合成树形结构，以表示“部分-整体”的层次结构。在这种结构中，组件可以访问叶节点的私有成员。

7. **策略模式（Strategy Pattern）**：
   策略模式定义了一系列算法，并将每一个算法封装起来，使它们可以互换。策略可以访问上下文（Context）对象的私有成员。

8. **模板方法模式（Template Method Pattern）**：
   模板方法模式在操作中定义了一个算法的框架，将一些步骤的执行延迟到子类中。在模板方法中，子类可以访问父类的私有成员。

9. **享元模式（Flyweight Pattern）**：
   享元模式用于高效地共享对象。享元可以访问内部状态的存储，这在某些情况下可以视为访问私有成员。

10. **访问者模式（Visitor Pattern）**：
    访问者模式允许在不修改类的情况下添加新的操作。访问者可以访问元素类的私有成员。

11. **观察者模式（Observer Pattern）**：
    观察者模式定义了对象之间的一对多依赖关系，当一个对象状态发生改变时，所有依赖于它的对象都会得到通知。在某些实现中，观察者可以访问被观察对象的私有状态。

12. **中介者模式（Mediator Pattern）**：
    中介者模式定义了一个中介对象，用以封装一系列对象之间的交互。中介者可以访问相互作用的各个对象的私有成员。

13. **工厂模式（Factory Pattern）**：
    工厂模式用于创建对象，而不需要指定将要创建的具体类。在某些实现中，工厂可以访问类的私有构造函数。

14. **单例模式（Singleton Pattern）**：
    单例模式确保一个类只有一个实例，并提供一个全局访问点。由于全局访问点可以访问类的私有成员，这在实现单例时很常见。

15. **命令模式（Command Pattern）**：
    命令模式将请求封装为一个对象，从而允许用户使用不同的请求、队列或日志请求。命令的执行者可以访问接收者的私有成员。

这些设计模式可以在不同的上下文和目的下使用，以实现对类私有成员的访问或操作。然而，设计模式的选择应基于具体问题的需求和上下文，以确保代码的清晰性、可维护性和扩展性。

---

## 关于作者

- 微信公众号:WeSiGJ
- GitHub:[https://github.com/wesigj/cplusplusboys](https://github.com/wesigj/cplusplusboys)
- CSDN:[https://blog.csdn.net/wesigj](https://blog.csdn.net/wesigj)
- 微博:
- 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

<img src=/img/wechat.jpg width=60% />
